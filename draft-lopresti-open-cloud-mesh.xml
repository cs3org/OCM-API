<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc version 1.7.19 (Ruby 3.3.0) -->


<!DOCTYPE rfc  [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">

]>


<rfc ipr="trust200902" docName="draft-lopresti-open-cloud-mesh-00" category="std" consensus="true">
  <front>
    <title>Open Cloud Mesh</title>

    <author initials="G." surname="Lo Presti" fullname="Giuseppe Lo Presti">
      <organization>CERN</organization>
      <address>
        <email>giuseppe.lopresti@cern.ch</email>
        <uri>http://cern.ch/lopresti</uri>
      </address>
    </author>
    <author initials="M. B." surname="de Jong" fullname="Michiel de Jong">
      <organization>Ponder Source</organization>
      <address>
        <email>michiel@pondersource.com</email>
        <uri>https:/pondersource.com</uri>
      </address>
    </author>
    <author initials="M." surname="Baghbani" fullname="Mahdi Baghbani">
      <organization>Ponder Source</organization>
      <address>
        <email>mahdi@pondersource.com</email>
        <uri>https:/pondersource.com</uri>
      </address>
    </author>
    <author initials="M." surname="Nordin" fullname="Micke Nordin">
      <organization>SUNET</organization>
      <address>
        <uri>https://code.smolnet.org/micke</uri>
      </address>
    </author>

    <date year="2024" month="September" day="06"/>

    <area>Security</area>
    
    <keyword>Internet-Draft</keyword>

    <abstract>


<?line 36?>

<t>Open Cloud Mesh is a server federation protocol that is used to notify a Receiving Party that they have
been granted access to some Resource. It has similarities with authorization flows such as OAuth, as well as with social internet protocols such as ActivityPub and email.</t>

<t>Open Cloud Mesh only handles the necessary interactions up to the point where the Receiving Party is informed that they were granted access to the Resource. The actual resource access is then left to protocols such as WebDAV and others.</t>



    </abstract>



  </front>

  <middle>


<?line 43?>

<section anchor="terms"><name>Terms</name>
<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
"OPTIONAL" in this document are to be interpreted as described in
RFC 2119.</t>

<t>We define the following concepts (with some non-normative references to related concepts from OAuth and elsewhere):</t>

<t><list style="symbols">
  <t><strong>Resource</strong> - the piece of data or interaction to which access is being granted, e.g. a file, folder, video call, or printer queue</t>
  <t><strong>Share</strong> - a policy rule stating that certain actors are allowed access to a Resource. Also: a record in a database representing this rule</t>
  <t><strong>Sending Party</strong> - a person or party who is authorized to create Shares (similar to "Resource Owner" in OAuth)</t>
  <t><strong>Receiving Party</strong> - a person, group or party who is granted access to the Resource through the Share (similar to "Requesting Party / RqP" in OAuth-UMA)</t>
  <t><strong>Sending Server</strong> - the server that:
  <list style="symbols">
      <t>holds the Resource ("file server" or "Entreprise File Sync and Share (EFSS) server" role),</t>
      <t>provides access to it (by exposing at least one "API"),</t>
      <t>takes the decision to create the Share based on user interface gestures from the Sending Party (the "Authorization Server" role in OAuth)</t>
      <t>takes the decision about authorizing attempts to access the Resource (the "Resource Server" role in OAuth)</t>
      <t>sends out Share Creation Notifications when appropriate (see below)</t>
    </list></t>
  <t><strong>Receiving Server</strong> - the server that:
  <list style="symbols">
      <t>receives Share Creation Notifications (see below)</t>
      <t>actively or passively notifies the receiving user or group of any incoming Share Creation Notification</t>
      <t>acts as an API client, allowing the receiving user to access the Resource through an API (e.g. WebDAV) of the sending server</t>
    </list></t>
  <t><strong>Sending Gesture</strong> - a user interface interaction from the Sending Party to the Sending Server, conveying the intention to create a Share</t>
  <t><strong>Share Creation</strong> - the addition of a Share to the database state of the Sending Server, in response to a successful Sending Gesture or for another reason</t>
  <t><strong>Share Creation Notification</strong> - a server-to-server request from the sending server to the receiving server, notifying the receiving server that a Share has been created</t>
  <t><strong>FQDN</strong> - Fully Qualified Domain Name, such as <spanx style="verb">"cloud.example.com"</spanx></t>
  <t><strong>OCM Server</strong> - a server that supports OCM.</t>
  <t><strong>Discovering Server</strong> - a server that tries to obtain information in OCM API discovery</t>
  <t><strong>Discoverable Server</strong> - a server that tries to supply information in OCM API discovery</t>
  <t><strong>OCM Address</strong> - a string of the form <spanx style="verb">&lt;Receiving Party's identifier&gt;@&lt;fqdn&gt;</spanx> which can be used to uniquely identify a user or group "at" an OCM Server. <spanx style="verb">&lt;Receiving Party's identifier&gt;</spanx> is an opaque string,
unique at the server. <spanx style="verb">&lt;fqdn&gt;</spanx> is the Fully Qualified Domain Name by which the server is identified. This can, but doesn't need to be, the domain at which the OCM API of that server is hosted.</t>
  <t><strong>Vanity OCM Address</strong> - a string that looks like an OCM Address but with an alternative (generally shorter or nicer) FQDN. This FQDN does not support HTTP-based discovery, but it does provide an SRV record in its DNS zone, pointing to the (generally longer or uglier) FQDN of the OCM Server.</t>
  <t><strong>Regular OCM Address</strong> - an OCM Address that is not a Vanity OCM Address</t>
  <t><strong>OCM Notification</strong> - a message from the Receiving Server to the Sending Server or vice versa, using the OCM Notifications endpoint.</t>
  <t><strong>Invite Message</strong> - out-of-band message used to establish contact between parties and servers in the Invite Flow, containing an Invite Token (see below) and the Invite Sender's OCM Address</t>
  <t><strong>Invite Sender</strong> - the party sending an Invite</t>
  <t><strong>Invite Receiver</strong> - the party receiving an Invite</t>
  <t><strong>Invite Sender OCM Server</strong> - the server holding an address book used by the Invite Sender, to which details of the Invite Receiver are to be added</t>
  <t><strong>Invite Receiver OCM Server</strong> - the server holding an address book used by the Invite Receiver, to which details of the Invite Sender are to be added</t>
  <t><strong>Invite Token</strong> - a hard-to-guess string used in the Invite Flow, generated by the Invite Sender OCM Server and linked uniquely to the Invite Sender's OCM Address</t>
  <t><strong>Invite Creation Gesture</strong> - gesture from the Invite Sender to the Invite Sender OCM Server, resulting in the creation of an Invite Token.</t>
  <t><strong>Invite Acceptance Gesture</strong> - gesture from the Invite Receiver to the Invite Receiver OCM Server, supplying the Invite Token as well as the OCM Address of the Invite Sender, effectively allowlisting the Invite Sender OCM Server for sending Share Creation Notifications to the Invite Receiver OCM Server.</t>
  <t><strong>Invite Acceptance Request</strong> - API call from the Invite Receiver OCM Server to the Invite Sender OCM Server, supplying the Invite Token as well as the OCM Address of the Invite Receiver, effectively allowlisting the Invite Sender OCM Server for sending Share Creation Notifications to the Invite Receiver OCM Server.</t>
  <t><strong>Invite Acceptance Response</strong> - HTTP response to the Invite Acceptance Request</t>
  <t><strong>Share Name</strong> - a human-readable string, provided by the Sending Party or the Sending Server, to help the Receiving Party understand which Resource the Share grants access to</t>
  <t><strong>Share Permissions</strong> - protocol-specific restrictions on the modes of accessing the Resource</t>
</list></t>

</section>
<section anchor="general-flow"><name>General Flow</name>
<t>The lifecycle of an Open Cloud Mesh Share starts with prerequisites such as
establishing trust, establishing contact, and OCM API discovery.</t>

<t>Then the share creation involves the Sending Party making a Sending Gesture to the Sending Server,
the Sending Server carrying out the actual Share Creation,
and the Sending Server sending a Share Creation Notification to the Receiving Server.</t>

<t>After this, the Receiving Server MAY notify the Receiving Party and/or the Sending Server, and will act as an API client
through which the Receiving Party can access the Resource. After that, the Share may be updated, deleted, and/or reshared.</t>

</section>
<section anchor="establishing-contact"><name>Establishing Contact</name>
<t>Before the Sending Server can send a Share Creation Notification to the Receiving Server, it needs to establish the Receiving Party's OCM Address (containing the Receiving Server's FQDN, and the Receiving Party's identifier), among other things.
Some steps may preceed the Sending Gesture, allowing the Sending Party to establish (with some level of trust) the OCM Address of the Receiving Party. In other cases, establishing the OCM Address
of the Receiving Party happens as part of the Sending Gesture.</t>

<section anchor="direct-entry"><name>Direct Entry</name>
<t>The simplest way for this is if the Receiving Party shares their OCM Address with the Sending Party through some out-of-band means, and the Sending Party enters this string into the user interface of the Sending Server, by means of typing or pasting into an HTML form, or clicking a link to a URL that includes the string in some form.</t>

</section>
<section anchor="address-books"><name>Address books</name>
<t>The Sending Server MAY offer the Sending Party an address book tool, where OCM Addresses can be stored over time in a labeled and/or searchable way. This decouples the act by which the OCM Address string is passed into the Sending Server's database from the selection of the Receiving Party in preparation for Share Creation.</t>

</section>
<section anchor="public-link-flow"><name>Public Link Flow</name>
<t>An interface for anonymously viewing a Resource on the Sending Server MAY allow any internet user to type or paste an OCM address into an HTML form, as a Sending Gesture. This means that the Sending Party and the Receiving Party could be the same person, so contact between them does not need to be explicitly established.</t>

</section>
<section anchor="public-invite-flow"><name>Public Invite Flow</name>
<t>Similarly, an interface on the Sending Server MAY allow any internet user to type or paste an OCM address into an HTML form, as a Sending Gesture for a given Resource, without itself providing a way to access that particular Resource. A link to this interface could then for instance be shared on a mailing list, allowing all subscribers to effectively request access to the Resource by making a Sending Gesture to the Sending Server with their own OCM Address.</t>

</section>
<section anchor="invite-flow"><name>Invite Flow</name>
<t>### Rationale
Many methods for establishing contact allow unsolicited contact with the prospective Receiving Party whenever that party's OCM Address is known. The Invite Flow requires the Receiving Party to explicitly accept it before it can be used, which establishes bidirectional trust between the two parties involved.</t>

<t>OCM Servers MAY enforce a policy to only accept Shares between such trusted contacts, or MAY display a warning to the Receiving Party when a Share Creation Notification from an unknown Sending Party is received</t>

<section anchor="steps"><name>Steps</name>

<t><list style="symbols">
  <t>the Invite Sender OCM Server generates a unique Invite Token and helps the Invite Sender to create the Invite Message</t>
  <t>the Invite Sender uses some out-of-band communication to send the Invite Message, containing the Invite Token and the Invite Sender OCM Server FQDN, to the Invite Receiver</t>
  <t>the Invite Receiver navigates to the Invite Receiver OCM Server (possibly using a Where-Are-You-From page provided as part of the Invite Message) and makes the Invite Acceptance Gesture</t>
  <t>the Invite Receiver OCM Server discovers the OCM API of the Invite Sender OCM Server using generic OCM API Discovery (see section below)</t>
  <t>the Invite Receiver OCM Server sends the Invite Acceptance Request to the Invite Sender OCM Server</t>
</list></t>

</section>
<section anchor="invite-acceptance-request-details"><name>Invite Acceptance Request Details</name>
<t>Whereas the precise syntax of the Invite Message and the Invite Acceptance Gesture will differ between implementations, the Invite Acceptance Request SHOULD be a HTTP POST request:</t>

<t><list style="symbols">
  <t>to the <spanx style="verb">/invited-accepted</spanx> path in the Invite Sender OCM Server's OCM API</t>
  <t>using <spanx style="verb">application/json</spanx> as the <spanx style="verb">Content-Type</spanx> HTTP request header</t>
  <t>its request body containing a JSON document representing an object with the following string fields:
  <list style="symbols">
      <t><spanx style="verb">recipientProvider</spanx> - FQDN of the Invite Receiver OCM Server</t>
      <t><spanx style="verb">token</spanx> - the Invite Token. The Invite Sender OCM Server SHOULD recall which Invite Sender OCM Address this token was linked to</t>
      <t><spanx style="verb">userID</spanx> - the Invite Receiver's identifier at their OCM Server</t>
      <t><spanx style="verb">email</spanx> - non-normative / informational; an email address for the Invite Receiver. Not necessarily at the same FQDN as their OCM Server</t>
      <t><spanx style="verb">name</spanx> - human-readable name of the Invite Receiver, as a suggestion for display in the Invite Sender's address book</t>
    </list></t>
  <t>using TLS</t>
  <t>using <eref target="https://datatracker.ietf.org/doc/html/draft-cavage-http-signatures-12">httpsig</eref></t>
</list></t>

<t>The Invite Receiver OCM Server SHOULD apply its own policies for trusting the Invite Sender OCM Server before making the Invite Acceptance Request.</t>

<t>Since the Invite Flow does not require either Party to type or remember the <spanx style="verb">userID</spanx>, this string does not need to be human-memorable. Even if the Invite Receiver has a memorable username at the Invite Receiver OCM Server, this <spanx style="verb">userID</spanx> that forms part of their OCM Address does not need to match it.</t>

<t>Also, a different <spanx style="verb">userID</spanx> could be given out to each contact, to avoid correlation of identities.</t>

</section>
<section anchor="invite-acceptance-response-details"><name>Invite Acceptance Response Details</name>
<t>The Invite Acceptance Response SHOULD be a HTTP response:</t>

<t><list style="symbols">
  <t>in response to the Invite Acceptance Request</t>
  <t>using <spanx style="verb">application/json</spanx> as the <spanx style="verb">Content-Type</spanx> HTTP response header</t>
  <t>its response body containing a JSON document representing an object with the following string fields:
  <list style="symbols">
      <t><spanx style="verb">userID</spanx> - the Invite Sender's identifier at their OCM Server</t>
      <t><spanx style="verb">email</spanx> - non-normative / informational; an email address for the Invite Sender. Not necessarily at the same FQDN as their OCM Server</t>
      <t><spanx style="verb">name</spanx> - human-readable name of the Invite Sender, as a suggestion for display in the Invite Receiver's address book</t>
    </list></t>
</list></t>

<t>A 200 response status means the Invitation Acceptance Request was successful.
A 400 response status means the Invitation Token is invalid or does not exist.
A 403 response status means the Invite Receiver OCM Server is not trusted to accept this Invite.
A 409 response status means the Invite was already accepted.</t>

<t>The Invite Sender OCM Server SHOULD verify the HTTP Signature on the Invite Acceptance Request and apply its own policies for trusting the Invite Receiver OCM Server before processing the Invite Acceptance Request and sending the Invite Acceptance Response.</t>

<t>As with the <spanx style="verb">userID</spanx> in the Invite Acceptance Request, the one in the Response also doesn't need to be human-memorable, doesn't need to match the Invite Sender's username at their OCM Server.</t>

</section>
<section anchor="addition-into-address-books"><name>Addition into address books</name>
<t>Following these step, both servers MAY display the <spanx style="verb">name</spanx> of the other party as a trusted or allowlisted contact, and enable selecting them as a Receiving Party. OCM Servers MAY enforce a policy to only accept Share Creation Notifications from such trusted contacts, or MAY display a warning to users when a Share Creation Notification from an unknown party is received.</t>

<t>Both servers MAY also allowlist each other as a server with which at least one of their users wishes to interact.</t>

<t>Note that Invites act symmetrically, so once contact has been established, both the Invite Sender and the Invite Receiver may take on either the Sending Party or the Receiving Party role in subsequent Share Creation events.</t>

<t>Both parties may delete the other party from their address book at any time without notifying them.</t>

</section>
<section anchor="security-advantages"><name>Security Advantages</name>
<t>It is important to underscore the value of the Invite in this scenario, as it provides four important security advantages. First of all, if the Receiving Server blocks Share Creation Notifications from Sending Parties who are not in the address book of the Receiving Party, then this protects the Receiving Party from receiving unsolicited Shares. An attacker could still send the Receiving Party an unsolicited Share, but they would first need to convince the Receiving Party through an out-of-band communication channel to accept their invite. In many use cases, the Receiving Party has had other forms of contact with the Sending Party (e.g. in-person or email back-and-forth). The out-of-band Invite Message thus leverages the filters and context which the Receiving Party may already benefit from in that out-of-band communication. For instance, a careful Receiving Party may choose to only accept Invites that reach them via a private or moderated messaging platform.</t>

<t>Second, when the Receiving Party accepts the Invite, the Receiving Server knows that the Sending Server they are about to interact with is trusted by the Sending Party, which in turn is trusted by the Receiving Party, which in turn is trusted by them. In other words, one of their users is requesting the allowlisting of a server they wish to interact with, in order to interact with a party they know out-of-band. This gives the Receiving Server reason to put more trust in the Sending Server than it would put into an arbitrary internet-hosted server.</t>

<t>Third, equivalently, the Sending Server knows it is essentially registering the Receiving Server as an API client at the request of the Receiving Party, to whom the right to request this has been traceably delegated by the Sending Party, which is one of its registered users.</t>

<t>Fourth, related to the second one, it removes the partial 'open relay' problem that exists when the Sending Server is allowed to include any Receiving Server FQDN in the Sending Gesture. Without the use of Invites, a Distributed Denial of Service attack could be organised if many internet users collude to flood a given OCM Server with Share Creation Notifications which will be hard to distinguish from legitimate requests without human interaction. An unsolicited (invalid) Invite Acceptance Request is much easier to filter out than an unsolicited (possibly valid, possibly invalid) OCM request, since the Invite Acceptance Request needs to contain an Invite Token that was previously uniquely generated at the Invite Sender OCM server.</t>

</section>
</section>
</section>
<section anchor="ocm-api-discovery"><name>OCM API Discovery</name>
<t>## Introduction
After establishing contact as discussed in the previous section, the Sharing User can send the Share Creation Gesture to the Sending Server, providing the Sending Server with the following information:</t>

<t><list style="symbols">
  <t>Resource to be shared</t>
  <t>Protocol to be offered for access</t>
  <t>Sending Party's identifier</t>
  <t>Receiving Party's identifier</t>
  <t>Receiving Server FQDN</t>
  <t>OPTIONAL: Share Name</t>
  <t>OPTIONAL: Share Permissions</t>
</list></t>

<t>The next step is for the Sending Server to additionally discover:</t>

<t><list style="symbols">
  <t>if the Receiving Server is trusted</t>
  <t>if the Receiving Server supports OCM</t>
  <t>if so, which version and with which optional functionality</t>
  <t>at which URL</t>
  <t>the public key the Receiving Server will use for HTTP Signatures (if any)</t>
</list></t>

<t>The Sending Server MAY first perform denylist and allowlist checks on the FQDN.</t>

<t>If a finite allowlist of Receiving Servers exists on the Sending Server side, then this list may already contain all necessary information.</t>

<t>If the FQDN passes the denylist and/or allowlist checks, but no details about its OCM API are known, the Sending Server can use the following process to try to fetch this information from the Receiving Server.</t>

<t>This process MAY be influenced by a VPN connection and/or IP allowlisting.</t>

<t>When OCM API discovery can occur in preparation of a Share Creation Notification, the Sending Server takes on the 'Discovering Server' role and the Receiving Server plays the role of 'Discoverable Server'.</t>

<section anchor="process"><name>Process</name>
<t>At the start of the process, the Discovering Server has either an OCM Address, or just an FQDN from for instance the <spanx style="verb">recipientProvider</spanx> field of an Invite Acceptance Request.</t>

<t>Step 1: In case it has an OCM Address, it should first extract <spanx style="verb">&lt;fqdn&gt;</spanx> from it (the part after the <spanx style="verb">@</spanx> sign).
Step 2: The Discovering Server SHOULD attempt OCM API discovery a HTTP GET request to <spanx style="verb">https://&lt;fqdn&gt;/.well-known/ocm</spanx>.
Step 3: If that results in a valid HTTP response with a valid JSON response body within reasonable time, go to step 8.
Step 4: If not, try a HTTP GET with <spanx style="verb">https://&lt;fqdn&gt;/ocm-provider</spanx> as the URL instead.
Step 5: If that results in a valid HTTP response with a valid JSON response body within reasonable time, go to step 8.
Step 6: If not, and the <spanx style="verb">&lt;fqdn&gt;</spanx> came from an OCM Address, then it SHOULD check if the OCM Address in question was a Vanity OCM Address.
This can be checked with a <spanx style="verb">type=SRV</spanx> DNS query to <spanx style="verb">_ocm._tcp.&lt;fqdn&gt;</spanx>. If that returns <spanx style="verb">service = 10 10 443 &lt;regular-fqdn&gt;</spanx> then repeat from step 2, using <spanx style="verb">&lt;regular-fqdn&gt;</spanx> instead of the <spanx style="verb">&lt;fqdn&gt;</spanx> that appeared in the Vanity OCM Address.
Step 7: If not, fail.
Step 8: The JSON response body is the data that was discovered.</t>

</section>
<section anchor="fields"><name>Fields</name>
<t>The JSON response body offered by the Discoverable Server SHOULD contain the following information about its OCM API:</t>

<t><list style="symbols">
  <t>REQUIRED: enabled (boolean) - Whether the OCM service is enabled at this endpoint</t>
  <t>REQUIRED: apiVersion (string) - The OCM API version this endpoint supports. Example: <spanx style="verb">"1.1.0"</spanx></t>
  <t>REQUIRED: endPoint (string) - The URI of the OCM API available at this endpoint. Example: <spanx style="verb">"https://my-cloud-storage.org/ocm"</spanx></t>
  <t>OPTIONAL: provider (string) - A friendly branding name of this endpoint. Example: <spanx style="verb">"MyCloudStorage"</spanx></t>
  <t>REQUIRED: resourceTypes (array) - A list of all supported resource types with their access protocols. Each item in this list should
itself be an object containing the following fields:
  <list style="symbols">
      <t>name (string) -  A supported resource type (file, folder, calendar, contact, ...).
            Implementations MUST support <spanx style="verb">file</spanx> at a minimum. Each resource type is identified by its <spanx style="verb">name</spanx>: the list MUST NOT
      contain more than one resource type object per given <spanx style="verb">name</spanx>.</t>
      <t>shareTypes (array of string) -
            The supported recipient share types.
            MUST contain <spanx style="verb">"user"</spanx> at a minimum, plus optionally <spanx style="verb">"group"</spanx> and <spanx style="verb">"federation"</spanx>.
            Example: <spanx style="verb">["user"]</spanx></t>
      <t>protocols (object) - The supported protocols for accessing shared resources.
            Implementations MUST support at least <spanx style="verb">webdav</spanx> for <spanx style="verb">file</spanx> resources,
            any other combination of resources and protocols is optional. Example:
            <spanx style="verb">json
            {
              "webdav": "/remote/dav/ocm/",
              "webapp": "/app/ocm/",
              "talk": "/apps/spreed/api/"
            }
           </spanx>
            Fields:
      <list style="symbols">
          <t>webdav (string) - The top-level WebDAV path at this endpoint. In order to access
              a remote shared resource, implementations MAY use this path
              as a prefix, or as the full path (see sharing examples).</t>
          <t>webapp (string) - The top-level path for web apps at this endpoint. This value
              is provided for documentation purposes, and it SHALL NOT
              be intended as a prefix for share requests.</t>
          <t>datatx (string) - The top-level path to be used for data transfers. This
              value is provided for documentation purposes, and it SHALL
              NOT be intended as a prefix. In addition, implementations
              are expected to execute the transfer using WebDAV as
              the wire protocol.</t>
          <t>Any additional protocol supported for this resource type MAY
              be advertised here, where the value MAY correspond to a top-level
              URI to be used for that protocol.</t>
        </list></t>
    </list></t>
  <t>OPTIONAL: capabilities (array of string) - The optional capabilities supported by this OCM Server.
        As implementations MUST accept Share Creation Notifications to be compliant,
        it is not necessary to expose that as a capability.
        Example: <spanx style="verb">["/notifications"]</spanx>. The array MAY include for instance:
  <list style="symbols">
      <t><spanx style="verb">"/notifications"</spanx> - to indicate this OCM server is capable of processing OCM Notifications</t>
      <t><spanx style="verb">"/invite-accepted"</spanx> - to indicate that this OCM server is capable of processing Invite Acceptance Requests.</t>
      <t><spanx style="verb">"/mfa-capable"</spanx> - to indicate that this OCM server can apply a Sending Server's MFA requirements for a Share on their behalf.</t>
    </list></t>
  <t>OPTIONAL: publicKey (object) - The signatory used to sign outgoing request to confirm its origin. The 
        signatory is optional, but if present, it MUST contain two string fields, <spanx style="verb">id</spanx> and <spanx style="verb">publicKeyPem</spanx>.
      properties:
  <list style="symbols">
      <t>REQUIRED id (string) unique id of the key in URI format. The hostname set the origin of the 
          request and MUST be identical to the current discovery endpoint.
        Example: https://my-cloud-storage.org/ocm#signature</t>
      <t>REQUIRED publicKeyPem (string) - PEM-encoded version of the public key.
        Example: "-----BEGIN PUBLIC KEY-----\nMII...QDD\n-----END PUBLIC KEY-----\n"</t>
    </list></t>
</list></t>

</section>
</section>
<section anchor="share-creation-notification"><name>Share Creation Notification</name>
<t>To create a share, the sending server SHOULD make a HTTP POST request</t>

<t><list style="symbols">
  <t>to the <spanx style="verb">/shares</spanx> path in the Receiving Server's OCM API</t>
  <t>using <spanx style="verb">application/json</spanx> as the <spanx style="verb">Content-Type</spanx> HTTP request header</t>
  <t>its request body containing a JSON document representing an object with the fields as described below</t>
  <t>using TLS</t>
  <t>using <eref target="https://datatracker.ietf.org/doc/html/draft-cavage-http-signatures-12">httpsig</eref></t>
</list></t>

<section anchor="fields-1"><name>Fields</name>

<t><list style="symbols">
  <t>REQUIRED shareWith (string)
        Consumer specific identifier of the user, group or federation the provider
        wants to share the resource with. This is known in advance.
        Please note that the consumer service endpoint is known in advance
        as well, so this is no part of the request body.
      Example: "51dc30ddc473d43a6011e9ebba6ca770@geant.org"</t>
  <t>REQUIRED name (string)
     Name of the resource (file or folder).
      Example: "resource.txt"</t>
  <t>OPTIONAL description (string)
      Optional description of the resource (file or folder).
      Example: "This is the Open API Specification file (in YAML format) of the Open
        Cloud Mesh API."</t>
  <t>REQUIRED providerId (string)
        Identifier to identify the shared resource at the provider side. This is
        unique per provider such that if the same resource is shared twice,
        this providerId will not be repeated.
      Example: 7c084226-d9a1-11e6-bf26-cec0c932ce01</t>
  <t>REQUIRED owner (string) -
        Provider specific identifier of the user who owns the resource.
      Example: "6358b71804dfa8ab069cf05ed1b0ed2a@apiwise.nl"</t>
  <t>REQUIRED sender (string) -
        Provider specific identifier of the user that wants to share the
        resource. Please note that the requesting provider is being
        identified on a higher level, so the former <spanx style="verb">remote</spanx> property
        is not part of the request body.
      Example: "527bd5b5d689e2c32ae974c6229ff785@apiwise.nl"</t>
  <t>OPTIONAL ownerDisplayName (string)
        Display name of the owner of the resource
      Example: "Dimitri"</t>
  <t>OPTIONAL senderDisplayName (string)
        Display name of the user that wants to share the resource
      Example: "John Doe"</t>
  <t>REQUIRED shareType (string)
      SHOULD have a value of "user", "group", or "federation", to indicated that the first part
      of the <spanx style="verb">shareWith</spanx> OCM Address refers to a Receiving Party who is a single user of the Receiving Server,
      a group of users at the Receiving Servers, or a group of users that is spread out over various servers,
      including at least one user at the Receiving Server.</t>
  <t>REQUIRED resourceType (string)
        Resource type (file, folder, calendar, contact, ...)</t>
  <t>OPTIONAL expiration (integer)
        The expiration time for the OCM share, in seconds
        of UTC time since Unix epoch. If omitted, it is assumed
        that the share does not expire.</t>
  <t>OPTIONAL code (string)
        A nonce to be exchanged for a (potentially short-lived) bearer token at the Sending Server's /token endpoint.</t>
  <t>REQUIRED protocol (object)
        JSON object with specific options for each protocol.
        The supported protocols are:
        - <spanx style="verb">webdav</spanx>, to access the data
        - <spanx style="verb">webapp</spanx>, to access remote web applications
        - <spanx style="verb">datatx</spanx>, to transfer the data to the remote endpoint  <vspace blankLines='1'/>
    <figure><artwork><![CDATA[
    Other custom protocols might be added in the future.

    In case a single protocol is offered, there are three ways to specify this object:
    Option 1: Set the `name` field to the name of the protocol, and put the protocol
    details in a field named `options`.
    Option 2: Set the `name` field to the name of the protocol, and put the protocol
    details in a field carrying the name of the protocol.
    Option 3: Set the `name` field to `multi`, and put the protocol
    details in a field carrying the name of the protocol.

          Option 1 using the `options` field now deprecated. Implementations are encouraged to
          transition to the new optional properties defined below, such that
          this field may be removed in a future major version of the spec.

    When specifying more than one protocol as different ways to access the Share, the `name`
    field needs to be set to `multi`.
]]></artwork></figure>
  </t>
</list></t>

<t>If <spanx style="verb">multi</spanx> is given, one or more protocol
                endpoints are expected to be defined according to the optional
                properties specified below.
                Otherwise, at least <spanx style="verb">webdav</spanx> is expected to be supported, and
                its options MAY be given in the opaque <spanx style="verb">options</spanx> payload for
                compatibility with v1.0 implementations (see examples). Note
                though that this format is deprecated.
                Warning: client implementers should be aware that v1.1 servers
                MAY support both <spanx style="verb">webdav</spanx> and <spanx style="verb">multi</spanx>, but v1.0 servers MAY
                only support <spanx style="verb">webdav</spanx>.</t>

<t><list style="symbols">
  <t>Protocol details for <spanx style="verb">webdav</spanx> MAY contain:
  <list style="symbols">
      <t>OPTIONAL sharedSecret (string) - required if no <spanx style="verb">code</spanx> field is given for the Share as a whole (see above).
             An optional secret to be used to access the resource,
             such as a bearer token.
             To prevent leaking it in logs it MUST NOT appear in any URI.</t>
      <t>OPTIONAL permissions (array of strings) -
               The permissions granted to the sharee. A subset of:
               - <spanx style="verb">read</spanx> allows read-only access including download of a copy.
               - <spanx style="verb">write</spanx> allows create, update, and delete rights on the resource.
               - <spanx style="verb">share</spanx> allows re-share rights on the resource.
               - <spanx style="verb">mfa-enforced</spanx> requires the user accessing the resource to be
                 MFA-authenticated. This permission MAY be used if the
                 provider exposes the <spanx style="verb">mfa-capable</spanx> capability.</t>
      <t>OPTIONAL uri (string)
             An URI to access the remote resource. The URI MAY be relative,
             in which case the prefix exposed by the <spanx style="verb">/ocm-provider</spanx> endpoint MUST
             be used, or it may be absolute (recommended). Additionally, the URI
             MAY include a secret hash in the path, in which case there MAY be
             no associated <spanx style="verb">sharedSecret</spanx>.</t>
    </list></t>
  <t>Protocol details for <spanx style="verb">webapp</spanx> MAY contain:
  <list style="symbols">
      <t>REQUIRED uriTemplate (string)
             A templated URI to a client-browsable view of the shared resource,
             such that users may use the web applications available at the site.
             The URI MAY include a secret hash in the path. If the path includes
             a <spanx style="verb">{relative-path-to-shared-resource}</spanx> placeholder, implementations
             MAY replace it with the actual path to ease user interaction.</t>
      <t>REQUIRED viewMode (string)
             The permissions granted to the sharee. A subset of:
             - <spanx style="verb">view</spanx> allows access to the web app in view-only mode.
             - <spanx style="verb">read</spanx> allows read and download access via the web app.
             - <spanx style="verb">write</spanx> allows full editing rights via the web app.
             - <spanx style="verb">mfa-enforced</spanx> requires the user accessing the resource to be
               MFA-authenticated. This permission MAY be used if the
               provider exposes the <spanx style="verb">mfa-capable</spanx> capability.</t>
      <t>OPTIONAL sharedSecret (string)
             An optional secret to be used to access the remote web app,
             for example in the form of a bearer token.</t>
    </list></t>
  <t>Protocol details for <spanx style="verb">datatx</spanx> MAY contain:
  <list style="symbols">
      <t>OPTIONAL sharedSecret (string)
             An optional secret to be used to access the resource,
             for example in the form of a bearer token.
             To prevent leaking it in logs it MUST NOT appear in any URI.</t>
      <t>REQUIRED srcUri (string)
             An URI to access the remote resource. The URI MAY be relative,
             in which case the prefix exposed by the <spanx style="verb">/ocm-provider</spanx> endpoint MUST
             be used, or it may be absolute (recommended). Additionally, the
             URI MAY include a secret hash in the path.</t>
      <t>OPTIONAL size (integer)</t>
    </list></t>
</list></t>

</section>
<section anchor="decision-to-discard"><name>Decision to Discard</name>
<t>The Receiving Server MAY discard the notification if any of the following hold true:</t>

<t><list style="symbols">
  <t>the HTTP Signature is missing</t>
  <t>the HTTP Signature is not valid</t>
  <t>no keypair is trusted or discoverable from the FQDN part of the <spanx style="verb">sender</spanx> field in the request body</t>
  <t>the keypair used to generate the HTTP Signature doesn't match the one trusted or discoverable from the FQDN part of the <spanx style="verb">sender</spanx> field in the request body</t>
  <t>the Sending Server is denylisted</t>
  <t>the Sending Server is not allowlisted</t>
  <t>the Sending Party is not trusted by the Receiving Party (e.g. no Invite was exchanged and/or the Sending Party's OCM Address does not appear in the Receiving Party's address book)</t>
  <t>the Receiving Server is unable to act as an API client for (any of) the protocol(s) listed for accessing the resource</t>
  <t>an initial check shows that the resource cannot successfully accessed through (any of) the protocol(s) listed</t>
</list></t>

</section>
</section>
<section anchor="receiving-party-notification"><name>Receiving Party Notification</name>
<t>If the Share Creation Notification is not discarded by the Receiving Server, they MAY notify the Receiving Party passively by adding the Share to some inbox list, and MAY also notify them actively through for instance a push notification or an email message.</t>

<t>They could give the Receiving Party the option to accept or reject the share, or add the share automatically and only send an informational notification that this happened.</t>

</section>
<section anchor="share-acceptance-notification"><name>Share Acceptance Notification</name>
<t>In response to a Share Creation Notification, the Receiving Server MAY discover the OCM API of the Sending Server,
starting from the <spanx style="verb">&lt;fqdn&gt;</spanx> part of the <spanx style="verb">sender</spanx> field in the Share Creation Notification.
Note that the <spanx style="verb">sender</spanx> field is not allowed to contain a Vanity OCM Address, so the fallback to SRV DNS records is not necessary in this OCM API discovery process.</t>

<t>If the OCM API of the Sending Server is successfully discovered, the Receiving Server MAY
make a HTTP POST request</t>

<t><list style="symbols">
  <t>to the <spanx style="verb">/notifications</spanx> path in the Sending Server's OCM API</t>
  <t>using <spanx style="verb">application/json</spanx> as the <spanx style="verb">Content-Type</spanx> HTTP request header</t>
  <t>its request body containing a JSON document representing an object with the fields as described below</t>
  <t>using TLS</t>
  <t>using <eref target="https://datatracker.ietf.org/doc/html/draft-cavage-http-signatures-12">httpsig</eref></t>
</list></t>

<section anchor="fields-2"><name>Fields</name>

<t><list style="symbols">
  <t>REQUIRED notificationType (string) - in a Share Acceptance Notification it SHOULD be one of:
  <list style="symbols">
      <t>'SHARE_ACCEPTED'</t>
      <t>'SHARE_DECLINED'</t>
    </list></t>
  <t>REQUIRED providerId (string) - copied from the Share Creation Notification for the Share this notification is about</t>
  <t>OPTIONAL resourceType (string) - copied from the Share Creation Notification for the Share this notification is about</t>
  <t>OPTIONAL notification (object) - optional additional parameters, depending on the notification and the resource type</t>
</list></t>

</section>
</section>
<section anchor="resource-access"><name>Resource Access</name>
<t>To access the Resource, the Receiving Server MAY use multiple ways, depending on the body of the Share Creation Notification and on the <spanx style="verb">protocol.name</spanx> property in there:</t>

<t><list style="symbols">
  <t>If <spanx style="verb">protocol.name</spanx> = <spanx style="verb">multi</spanx>, the receiver MUST make a HTTP PROPFIND request to <spanx style="verb">protocol.webdav.uri</spanx> to access the remote share.
If <spanx style="verb">code</spanx> is not empty, the receiver SHOULD discover the sender's OCM endpoint and make a signed POST request to the <spanx style="verb">/token</spanx> path inside the Sending Server's OCM API, to exchange
the code for a short-lived bearer token,
and then use that bearer token to access the Resource.
Otherwise, if <spanx style="verb">protocol.webdav.sharedSecret</spanx> is not empty, the receiver MUST pass it as a <spanx style="verb">Authorization: bearer</spanx> header.</t>
  <t>If <spanx style="verb">protocol.name</spanx> = <spanx style="verb">webdav</spanx>, the receiver SHOULD inspect the <spanx style="verb">protocol.options</spanx> property. If it contains a <spanx style="verb">sharedSecret</spanx>, as in the <eref target="https://cs3org.github.io/OCM-API/docs.html?branch=develop&amp;repo=OCM-API&amp;user=cs3org#/paths/~1shares/post">legacy example</eref>, then the receiver SHOULD make a HTTP PROPFIND request to <spanx style="verb">https://&lt;sharedSecret&gt;:@&lt;host&gt;&lt;path&gt;</spanx>, where <spanx style="verb">&lt;host&gt;</spanx> is the remote server, and <spanx style="verb">&lt;path&gt;</spanx> is obtained by querying the <xref target="ocm-api-discovery">Discovery</xref> endpoint at the Sending Server and getting <spanx style="verb">resourceTypes[0].protocols.webdav</spanx>. Note that this access method is <em>deprecated</em> and may be removed in a future release of the Protocol.</t>
</list></t>

<t>In both cases, when the Resource is a folder and the Receiving Server accesses a resource within that shared folder, it SHOULD append its relative path to that URL.</t>

<t>Additionally, if <spanx style="verb">protocol.&lt;protocolname&gt;.permissions</spanx> include <spanx style="verb">mfa-enforced</spanx>, the Receiving Server MUST ensure that the Receiving Party has been authenticated with MFA.</t>

</section>
<section anchor="share-deletion"><name>Share Deletion</name>
<t>A <spanx style="verb">"SHARE_ACCEPTED"</spanx> notification followed by a <spanx style="verb">"SHARE_UNSHARED"</spanx> notification is
equivalent to a <spanx style="verb">"SHARE_DECLINED"</spanx> notification.</t>

<t>Note that the Sending Server MAY at any time revoke access to a Resource (effectively undoing or deleting the Share) without notifying the Receiving Server.</t>

</section>
<section anchor="share-updating"><name>Share Updating</name>
<t>TODO: document <spanx style="verb">"RESHARE_CHANGE_PERMISSION"</spanx></t>

</section>
<section anchor="resharing"><name>Resharing</name>
<t>The <spanx style="verb">"REQUEST_RESHARE"</spanx> and <spanx style="verb">"RESHARE_UNDO"</spanx> notification types MAY be used by the
Receiving Server to persuade the Sending Server to share the same Resource with another Receiving Party.
TODO: document how the Receiving Party can know if the Sending Party understood and processed the
reshare request.</t>

</section>
<section anchor="appendix-a-multi-factor-authentication"><name>Appendix A: Multi Factor Authentication</name>
<t>If a Receiving Server exposes the capability <spanx style="verb">/mfa-capable</spanx>, it indicates that it will try and comply with a MFA requirement set as a permission on a Share. If the Sending Server trusts the Receiving Server, the Sending Server MAY set the permission <spanx style="verb">mfa-enforced</spanx> on a Share, which the Receiving Server SHOULD honor. A compliant Receiving Server that signals that it is MFA-capable MUST not allow access to a resource protected with the <spanx style="verb">mfa-enforced</spanx> permission, if the Receiving Party has not provided a second factor to establish their identity with greater confidence.</t>

<t>Since there is no way to guarantee that the Receiving Server will actually enforce the MFA requirement, it is up to the Sending Server to establish a trust with the Receiving Server such that it is reasonable to assume that the Receiving Server will honor the MFA requirement. This establishment of trust will inevitably be implementation dependent, and can be done for example using a pre approved allow list of trusted Receiving Servers. The procedure of establishing trust is out of scope for this specification: a mechanism similar to the <eref target="https://sciencemesh.io">ScienceMesh</eref> integration for the <xref target="invite-flow">Invite</xref> capability may be envisaged.</t>

</section>
<section anchor="appendix-b-request-signing"><name>Appendix B: Request Signing</name>

<t>A request is signed by adding the signature in the headers. The sender also needs to expose the public key used to generate the signature. The receiver can then validate the signature and therefore the origin of the request.
To help debugging, it is recommended to also add all properties used in the signature as headers, even if they can easily be re-generated from the payload.</t>

<t>Note: Signed requests prove the identity of the sender but does not encrypt nor affect its payload.</t>

<t>Here is an example of headers needed to sign a request.</t>

<t><list style="symbols">
  <t>'(request-target)' contains the reached endpoint and the used method,</t>
  <t>'content-length' is the total length of the payload of the request,</t>
  <t>'date' is the date and time when the request has been sent,</t>
  <t>'digest' is a checksum of the payload of the request,</t>
  <t>'host' is the hostname of the recipient of the request (remote when signing outgoing request, local on incoming request),</t>
  <t>'Signature' contains the signature generated using the private key and details on its generation:
  <list style="symbols">
      <t>'keyId' is a unique id, formatted as an url. hostname is used to retrieve the public key via custom discovery</t>
      <t>'algorithm' specify the algorithm used to generate signature</t>
      <t>'headers' specify the properties used when generating the signature</t>
      <t>'signature' the signature of an array containing the properties listed in 'headers'. Some properties like content-length, date, digest, and host are mandatory to protect against authenticity override.</t>
    </list></t>
</list></t>

<section anchor="how-to-generate-the-signature-for-outgoing-request"><name>How to generate the Signature for outgoing request</name>

<t>After properties are set in the headers, the Signature is generated and added to the list.</t>

<t>This is a quick PHP example of headers for outgoing request:</t>

</section>
<section anchor="how-to-confirm-signature-on-incoming-request"><name>How to confirm Signature on incoming request</name>

<t>The first step would be to confirm the validity of each properties:</t>

<t><list style="symbols">
  <t>'(request-target)' and 'host' are immutable to the type of the request and the local/current host,</t>
  <t>'content-length' and 'digest' can be re-generated and compared from the payload of the request,</t>
  <t>A maximum TTL must be applied to 'date' and current timestamp,</t>
  <t>regarding data contained in the 'Signature' header:
  <list style="symbols">
      <t>using 'keyId' to get the public key from remote signatory,</t>
      <t>'headers' is used to generate the clear version of the signature and must contain at least 'content-length', 'date', 'digest' and 'host',</t>
      <t>'signature' is the encrypted version of the signature.</t>
    </list></t>
</list></t>

<t>Here is an example of how to verify the signature using the headers, the signature and the public key:</t>

</section>
<section anchor="validating-the-payload"><name>Validating the payload</name>

<t>Following the validation of the signature, the host should also confirm the validity of the payload, that is ensuring that the actions implied in the payload actually initiated on behalf of the source of the request.</t>

<t>As an example, if the payload is about initiating a new share the file owner has to be an account from the instance at the origin of the request.</t>

</section>
</section>


  </middle>

  <back>








  </back>

<!-- ##markdown-source:
H4sIAAAAAAAAA+19a3PbRpbod/4KlFK1kqZISrYTO9ZNcsNYcqJZW1YkOalU
dspsAk0SYxDgAKBkztbe337Pq19AU3I8SXY/rCopSyTQffr0OafPu0ej0aDN
20KfJPtv1rpMXhTVJkte62a5P8iqtFQr+Cqr1bwdFdW61k2bjyp4cJTig6MV
PDg6Ph6kqtWLqt6eJE2bDQb5uj5J2nrTtI+Pj58fPx6oWquT5Fqnmzpvt4P3
entX1dlJcl62ui51OzrFKQaDplVl9k4VVQnTbnUzGKhNu6zqk0GSjJK8bE6S
78fJqyq5JFDg0yRhGL/PN41er3Xny6peqDL/p2rzqjxJXpxdXdDHeqXy4iRZ
yEtjs7ZvUwBnnC7pIYD1JFm27frk6Eg+PzIPDhxAr8ffjZNMJ3+tyoUH0Os8
Xea6CL4JobmsykzXyXW1qVPtg7XiV79d0wMNfT9Oq1UIVXNy1HvAhyr5Ti2W
M5jPB0otszz84mNhwjf/VYguYNPzMkTSe+1/HEJz/fbi7KY3x1FaZXrcrKoC
KGcMbxytcJjBYDQaJWrWtLVKgZY69JzkTaKSRte3sL65BihpkmRdV22VVkXS
LlWLDwFJZElbJWXV5vMtvHOlU53f5uUiuVR1u+UH26XeJkt1qwczDfMsagWk
nCUqTXXT4OtNtdLwqqAiOW/h6SZp8lVeKGCCXDfJXd4uEyZwWXIyL6o7eGqT
whdN8mYCXw7xtztdFPQvvtJUaa4KwCozj12Ce3GStgBxu73czBLgKN7EcR8n
VVngKsqsAHBgSUmpEX5Vb3l0QCRABThZ45LwgXUFXyR3S11r+ruLHEBgXs6r
eoVItIi6w8f7OOIBDIpu4C+YcANLq+VD82xO0JVJoectvthf8c96djr5iRZb
waN1M2Z6WOUZLG4w+Cy50fWqGeAk7xEioLkm2Xv99vpmb8j/Jhdv6Persx/f
nl+dneLv1z9MXr2yvwzkiesf3rx9dep+c2++ePP69dnFKb0Mo05+gX8BpsHe
m8ub8zcXk1d7gB5YCywIxOtmpQGZClFZJTPNOAcBQ1iCJ3ST1vkM/gDuuHr5
Inn86NFzWNfPGr6a5yXvwLwqgGhwB9KqTPW6bZIDIROgwLIqRyVsB5DXrQa8
zmEn4ClCf60LhVPZ9+Z1tWKiY6opGk07fXgyGPwleffO7NW7d8DURA05bH9S
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
/weQz15L6aEAAA==

-->

</rfc>

