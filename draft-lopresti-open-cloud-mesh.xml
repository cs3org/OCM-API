<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc version 1.7.19 (Ruby 3.3.0) -->


<!DOCTYPE rfc  [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">

]>


<rfc ipr="trust200902" docName="draft-lopresti-open-cloud-mesh-00" category="std" consensus="true">
  <front>
    <title>Open Cloud Mesh</title>

    <author initials="G." surname="Lo Presti" fullname="Giuseppe Lo Presti">
      <organization>CERN</organization>
      <address>
        <email>giuseppe.lopresti@cern.ch</email>
        <uri>http://cern.ch/lopresti</uri>
      </address>
    </author>
    <author initials="M. B." surname="de Jong" fullname="Michiel de Jong">
      <organization>Ponder Source</organization>
      <address>
        <email>michiel@pondersource.com</email>
        <uri>https:/pondersource.com</uri>
      </address>
    </author>
    <author initials="M." surname="Baghbani" fullname="Mahdi Baghbani">
      <organization>Ponder Source</organization>
      <address>
        <email>mahdi@pondersource.com</email>
        <uri>https:/pondersource.com</uri>
      </address>
    </author>
    <author initials="M." surname="Nordin" fullname="Micke Nordin">
      <organization>SUNET</organization>
      <address>
        <uri>https://code.smolnet.org/micke</uri>
      </address>
    </author>

    <date year="2024" month="September" day="06"/>

    <area>Security</area>
    
    <keyword>Internet-Draft</keyword>

    <abstract>


<?line 36?>

<t>Open Cloud Mesh is a server federation protocol that is used to notify a Receiving Party that they have
been granted access to some Resource. It has similarities with authorization flows such as OAuth, as well as with social internet protocols such as ActivityPub and email.</t>

<t>Open Cloud Mesh only handles the necessary interactions up to the point where the Receiving Party is informed that they were granted access to the Resource. The actual resource access is then left to protocols such as WebDAV and others.</t>



    </abstract>



  </front>

  <middle>


<?line 43?>

<section anchor="terms"><name>Terms</name>
<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
"OPTIONAL" in this document are to be interpreted as described in
RFC 2119.</t>

<t>We define the following concepts (with some non-normative references to related concepts from OAuth and elsewhere):</t>

<t><list style="symbols">
  <t><strong>Resource</strong> - the piece of data or interaction to which access is being granted, e.g. a file, folder, video call, or printer queue</t>
  <t><strong>Share</strong> - a policy rule stating that certain actors are allowed access to a Resource. Also: a record in a database representing this rule</t>
  <t><strong>Sending Party</strong> - a person or party who is authorized to create Shares (similar to "Resource Owner" in OAuth)</t>
  <t><strong>Receiving Party</strong> - a person, group or party who is granted access to the Resource through the Share (similar to "Requesting Party / RqP" in OAuth-UMA)</t>
  <t><strong>Sending Server</strong> - the server that:
  <list style="symbols">
      <t>holds the Resource ("file server" or "Entreprise File Sync and Share (EFSS) server" role),</t>
      <t>provides access to it (by exposing at least one "API"),</t>
      <t>takes the decision to create the Share based on user interface gestures from the Sending Party (the "Authorization Server" role in OAuth)</t>
      <t>takes the decision about authorizing attempts to access the Resource (the "Resource Server" role in OAuth)</t>
      <t>sends out Share Creation Notifications when appropriate (see below)</t>
    </list></t>
  <t><strong>Receiving Server</strong> - the server that:
  <list style="symbols">
      <t>receives Share Creation Notifications (see below)</t>
      <t>actively or passively notifies the receiving user or group of any incoming Share Creation Notification</t>
      <t>acts as an API client, allowing the receiving user to access the Resource through an API (e.g. WebDAV) of the sending server</t>
    </list></t>
  <t><strong>Sending Gesture</strong> - a user interface interaction from the Sending Party to the Sending Server, conveying the intention to create a Share</t>
  <t><strong>Share Creation</strong> - the addition of a Share to the database state of the Sending Server, in response to a successful Sending Gesture or for another reason</t>
  <t><strong>Share Creation Notification</strong> - a server-to-server request from the sending server to the receiving server, notifying the receiving server that a Share has been created</t>
  <t><strong>FQDN</strong> - Fully Qualified Domain Name, such as <spanx style="verb">"cloud.example.com"</spanx></t>
  <t><strong>OCM Server</strong> - a server that supports OCM.</t>
  <t><strong>Discovering Server</strong> - a server that tries to obtain information in OCM API discovery</t>
  <t><strong>Discoverable Server</strong> - a server that tries to supply information in OCM API discovery</t>
  <t><strong>OCM Address</strong> - a string of the form <spanx style="verb">&lt;Receiving Party's identifier&gt;@&lt;fqdn&gt;</spanx> which can be used to uniquely identify a user or group "at" an OCM Server. <spanx style="verb">&lt;Receiving Party's identifier&gt;</spanx> is an opaque string,
unique at the server. <spanx style="verb">&lt;fqdn&gt;</spanx> is the Fully Qualified Domain Name by which the server is identified. This can, but doesn't need to be, the domain at which the OCM API of that server is hosted.</t>
  <t><strong>Vanity OCM Address</strong> - a string that looks like an OCM Address but with an alternative (generally shorter or nicer) FQDN. This FQDN does not support HTTP-based discovery, but it does provide an SRV record in its DNS zone, pointing to the (generally longer or uglier) FQDN of the OCM Server.</t>
  <t><strong>Regular OCM Address</strong> - an OCM Address that is not a Vanity OCM Address</t>
  <t><strong>OCM Notification</strong> - a message from the Receiving Server to the Sending Server or vice versa, using the OCM Notifications endpoint.</t>
  <t><strong>Invite Message</strong> - out-of-band message used to establish contact between parties and servers in the Invite Flow, containing an Invite Token (see below) and the Invite Sender's OCM Address</t>
  <t><strong>Invite Sender</strong> - the party sending an Invite</t>
  <t><strong>Invite Receiver</strong> - the party receiving an Invite</t>
  <t><strong>Invite Sender OCM Server</strong> - the server holding an address book used by the Invite Sender, to which details of the Invite Receiver are to be added</t>
  <t><strong>Invite Receiver OCM Server</strong> - the server holding an address book used by the Invite Receiver, to which details of the Invite Sender are to be added</t>
  <t><strong>Invite Token</strong> - a hard-to-guess string used in the Invite Flow, generated by the Invite Sender OCM Server and linked uniquely to the Invite Sender's OCM Address</t>
  <t><strong>Invite Creation Gesture</strong> - gesture from the Invite Sender to the Invite Sender OCM Server, resulting in the creation of an Invite Token.</t>
  <t><strong>Invite Acceptance Gesture</strong> - gesture from the Invite Receiver to the Invite Receiver OCM Server, supplying the Invite Token as well as the OCM Address of the Invite Sender, effectively allowlisting the Invite Sender OCM Server for sending Share Creation Notifications to the Invite Receiver OCM Server.</t>
  <t><strong>Invite Acceptance Request</strong> - API call from the Invite Receiver OCM Server to the Invite Sender OCM Server, supplying the Invite Token as well as the OCM Address of the Invite Receiver, effectively allowlisting the Invite Sender OCM Server for sending Share Creation Notifications to the Invite Receiver OCM Server.</t>
  <t><strong>Invite Acceptance Response</strong> - HTTP response to the Invite Acceptance Request</t>
  <t><strong>Share Name</strong> - a human-readable string, provided by the Sending Party or the Sending Server, to help the Receiving Party understand which Resource the Share grants access to</t>
  <t><strong>Share Permissions</strong> - protocol-specific restrictions on the modes of accessing the Resource</t>
</list></t>

</section>
<section anchor="general-flow"><name>General Flow</name>
<t>The lifecycle of an Open Cloud Mesh Share starts with prerequisites such as
establishing trust, establishing contact, and OCM API discovery.</t>

<t>Then the share creation involves the Sending Party making a Sending Gesture to the Sending Server,
the Sending Server carrying out the actual Share Creation,
and the Sending Server sending a Share Creation Notification to the Receiving Server.</t>

<t>After this, the Receiving Server MAY notify the Receiving Party and/or the Sending Server, and will act as an API client
through which the Receiving Party can access the Resource. After that, the Share may be updated, deleted, and/or reshared.</t>

</section>
<section anchor="establishing-contact"><name>Establishing Contact</name>
<t>Before the Sending Server can send a Share Creation Notification to the Receiving Server, it needs to establish the Receiving Party's OCM Address (containing the Receiving Server's FQDN, and the Receiving Party's identifier), among other things.
Some steps may preceed the Sending Gesture, allowing the Sending Party to establish (with some level of trust) the OCM Address of the Receiving Party. In other cases, establishing the OCM Address
of the Receiving Party happens as part of the Sending Gesture.</t>

<section anchor="direct-entry"><name>Direct Entry</name>
<t>The simplest way for this is if the Receiving Party shares their OCM Address with the Sending Party through some out-of-band means, and the Sending Party enters this string into the user interface of the Sending Server, by means of typing or pasting into an HTML form, or clicking a link to a URL that includes the string in some form.</t>

</section>
<section anchor="address-books"><name>Address books</name>
<t>The Sending Server MAY offer the Sending Party an address book tool, where OCM Addresses can be stored over time in a labeled and/or searchable way. This decouples the act by which the OCM Address string is passed into the Sending Server's database from the selection of the Receiving Party in preparation for Share Creation.</t>

</section>
<section anchor="public-link-flow"><name>Public Link Flow</name>
<t>An interface for anonymously viewing a Resource on the Sending Server MAY allow any internet user to type or paste an OCM address into an HTML form, as a Sending Gesture. This means that the Sending Party and the Receiving Party could be the same person, so contact between them does not need to be explicitly established.</t>

</section>
<section anchor="public-invite-flow"><name>Public Invite Flow</name>
<t>Similarly, an interface on the Sending Server MAY allow any internet user to type or paste an OCM address into an HTML form, as a Sending Gesture for a given Resource, without itself providing a way to access that particular Resource. A link to this interface could then for instance be shared on a mailing list, allowing all subscribers to effectively request access to the Resource by making a Sending Gesture to the Sending Server with their own OCM Address.</t>

</section>
<section anchor="invite-flow"><name>Invite Flow</name>
<t>### Rationale
Many methods for establishing contact allow unsolicited contact with the prospective Receiving Party whenever that party's OCM Address is known. The Invite Flow requires the Receiving Party to explicitly accept it before it can be used, which establishes bidirectional trust between the two parties involved.</t>

<t>OCM Servers MAY enforce a policy to only accept Shares between such trusted contacts, or MAY display a warning to the Receiving Party when a Share Creation Notification from an unknown Sending Party is received</t>

<section anchor="steps"><name>Steps</name>

<t><list style="symbols">
  <t>the Invite Sender OCM Server generates a unique Invite Token and helps the Invite Sender to create the Invite Message</t>
  <t>the Invite Sender uses some out-of-band communication to send the Invite Message, containing the Invite Token and the Invite Sender OCM Server FQDN, to the Invite Receiver</t>
  <t>the Invite Receiver navigates to the Invite Receiver OCM Server (possibly using a Where-Are-You-From page provided as part of the Invite Message) and makes the Invite Acceptance Gesture</t>
  <t>the Invite Receiver OCM Server discovers the OCM API of the Invite Sender OCM Server using generic OCM API Discovery (see section below)</t>
  <t>the Invite Receiver OCM Server sends the Invite Acceptance Request to the Invite Sender OCM Server</t>
</list></t>

</section>
<section anchor="invite-acceptance-request-details"><name>Invite Acceptance Request Details</name>
<t>Whereas the precise syntax of the Invite Message and the Invite Acceptance Gesture will differ between implementations, the Invite Acceptance Request SHOULD be a HTTP POST request:</t>

<t><list style="symbols">
  <t>to the <spanx style="verb">/invited-accepted</spanx> path in the Invite Sender OCM Server's OCM API</t>
  <t>using <spanx style="verb">application/json</spanx> as the <spanx style="verb">Content-Type</spanx> HTTP request header</t>
  <t>its request body containing a JSON document representing an object with the following string fields:
  <list style="symbols">
      <t><spanx style="verb">recipientProvider</spanx> - FQDN of the Invite Receiver OCM Server</t>
      <t><spanx style="verb">token</spanx> - the Invite Token. The Invite Sender OCM Server SHOULD recall which Invite Sender OCM Address this token was linked to</t>
      <t><spanx style="verb">userID</spanx> - the Invite Receiver's identifier at their OCM Server</t>
      <t><spanx style="verb">email</spanx> - non-normative / informational; an email address for the Invite Receiver. Not necessarily at the same FQDN as their OCM Server</t>
      <t><spanx style="verb">name</spanx> - human-readable name of the Invite Receiver, as a suggestion for display in the Invite Sender's address book</t>
    </list></t>
  <t>using TLS</t>
  <t>using <eref target="https://datatracker.ietf.org/doc/html/draft-cavage-http-signatures-12">httpsig</eref></t>
</list></t>

<t>The Invite Receiver OCM Server SHOULD apply its own policies for trusting the Invite Sender OCM Server before making the Invite Acceptance Request.</t>

<t>Since the Invite Flow does not require either Party to type or remember the <spanx style="verb">userID</spanx>, this string does not need to be human-memorable. Even if the Invite Receiver has a memorable username at the Invite Receiver OCM Server, this <spanx style="verb">userID</spanx> that forms part of their OCM Address does not need to match it.</t>

<t>Also, a different <spanx style="verb">userID</spanx> could be given out to each contact, to avoid correlation of identities.</t>

</section>
<section anchor="invite-acceptance-response-details"><name>Invite Acceptance Response Details</name>
<t>The Invite Acceptance Response SHOULD be a HTTP response:</t>

<t><list style="symbols">
  <t>in response to the Invite Acceptance Request</t>
  <t>using <spanx style="verb">application/json</spanx> as the <spanx style="verb">Content-Type</spanx> HTTP response header</t>
  <t>its response body containing a JSON document representing an object with the following string fields:
  <list style="symbols">
      <t><spanx style="verb">userID</spanx> - the Invite Sender's identifier at their OCM Server</t>
      <t><spanx style="verb">email</spanx> - non-normative / informational; an email address for the Invite Sender. Not necessarily at the same FQDN as their OCM Server</t>
      <t><spanx style="verb">name</spanx> - human-readable name of the Invite Sender, as a suggestion for display in the Invite Receiver's address book</t>
    </list></t>
</list></t>

<t>A 200 response status means the Invitation Acceptance Request was successful.
A 400 response status means the Invitation Token is invalid or does not exist.
A 403 response status means the Invite Receiver OCM Server is not trusted to accept this Invite.
A 409 response status means the Invite was already accepted.</t>

<t>The Invite Sender OCM Server SHOULD verify the HTTP Signature on the Invite Acceptance Request and apply its own policies for trusting the Invite Receiver OCM Server before processing the Invite Acceptance Request and sending the Invite Acceptance Response.</t>

<t>As with the <spanx style="verb">userID</spanx> in the Invite Acceptance Request, the one in the Response also doesn't need to be human-memorable, doesn't need to match the Invite Sender's username at their OCM Server.</t>

</section>
<section anchor="addition-into-address-books"><name>Addition into address books</name>
<t>Following these step, both servers MAY display the <spanx style="verb">name</spanx> of the other party as a trusted or allowlisted contact, and enable selecting them as a Receiving Party. OCM Servers MAY enforce a policy to only accept Share Creation Notifications from such trusted contacts, or MAY display a warning to users when a Share Creation Notification from an unknown party is received.</t>

<t>Both servers MAY also allowlist each other as a server with which at least one of their users wishes to interact.</t>

<t>Note that Invites act symmetrically, so once contact has been established, both the Invite Sender and the Invite Receiver may take on either the Sending Party or the Receiving Party role in subsequent Share Creation events.</t>

<t>Both parties may delete the other party from their address book at any time without notifying them.</t>

</section>
<section anchor="security-advantages"><name>Security Advantages</name>
<t>It is important to underscore the value of the Invite in this scenario, as it provides four important security advantages. First of all, if the Receiving Server blocks Share Creation Notifications from Sending Parties who are not in the address book of the Receiving Party, then this protects the Receiving Party from receiving unsolicited Shares. An attacker could still send the Receiving Party an unsolicited Share, but they would first need to convince the Receiving Party through an out-of-band communication channel to accept their invite. In many use cases, the Receiving Party has had other forms of contact with the Sending Party (e.g. in-person or email back-and-forth). The out-of-band Invite Message thus leverages the filters and context which the Receiving Party may already benefit from in that out-of-band communication. For instance, a careful Receiving Party may choose to only accept Invites that reach them via a private or moderated messaging platform.</t>

<t>Second, when the Receiving Party accepts the Invite, the Receiving Server knows that the Sending Server they are about to interact with is trusted by the Sending Party, which in turn is trusted by the Receiving Party, which in turn is trusted by them. In other words, one of their users is requesting the allowlisting of a server they wish to interact with, in order to interact with a party they know out-of-band. This gives the Receiving Server reason to put more trust in the Sending Server than it would put into an arbitrary internet-hosted server.</t>

<t>Third, equivalently, the Sending Server knows it is essentially registering the Receiving Server as an API client at the request of the Receiving Party, to whom the right to request this has been traceably delegated by the Sending Party, which is one of its registered users.</t>

<t>Fourth, related to the second one, it removes the partial 'open relay' problem that exists when the Sending Server is allowed to include any Receiving Server FQDN in the Sending Gesture. Without the use of Invites, a Distributed Denial of Service attack could be organised if many internet users collude to flood a given OCM Server with Share Creation Notifications which will be hard to distinguish from legitimate requests without human interaction. An unsolicited (invalid) Invite Acceptance Request is much easier to filter out than an unsolicited (possibly valid, possibly invalid) OCM request, since the Invite Acceptance Request needs to contain an Invite Token that was previously uniquely generated at the Invite Sender OCM server.</t>

</section>
</section>
</section>
<section anchor="ocm-api-discovery"><name>OCM API Discovery</name>
<t>## Introduction
After establishing contact as discussed in the previous section, the Sharing User can send the Share Creation Gesture to the Sending Server, providing the Sending Server with the following information:</t>

<t><list style="symbols">
  <t>Resource to be shared</t>
  <t>Protocol to be offered for access</t>
  <t>Sending Party's identifier</t>
  <t>Receiving Party's identifier</t>
  <t>Receiving Server FQDN</t>
  <t>OPTIONAL: Share Name</t>
  <t>OPTIONAL: Share Permissions</t>
</list></t>

<t>The next step is for the Sending Server to additionally discover:</t>

<t><list style="symbols">
  <t>if the Receiving Server is trusted</t>
  <t>if the Receiving Server supports OCM</t>
  <t>if so, which version and with which optional functionality</t>
  <t>at which URL</t>
  <t>the public key the Receiving Server will use for HTTP Signatures (if any)</t>
</list></t>

<t>The Sending Server MAY first perform denylist and allowlist checks on the FQDN.</t>

<t>If a finite allowlist of Receiving Servers exists on the Sending Server side, then this list may already contain all necessary information.</t>

<t>If the FQDN passes the denylist and/or allowlist checks, but no details about its OCM API are known, the Sending Server can use the following process to try to fetch this information from the Receiving Server.</t>

<t>This process MAY be influenced by a VPN connection and/or IP allowlisting.</t>

<t>When OCM API discovery can occur in preparation of a Share Creation Notification, the Sending Server takes on the 'Discovering Server' role and the Receiving Server plays the role of 'Discoverable Server'.</t>

<section anchor="process"><name>Process</name>
<t>At the start of the process, the Discovering Server has either an OCM Address, or just an FQDN from for instance the <spanx style="verb">recipientProvider</spanx> field of an Invite Acceptance Request.</t>

<t>Step 1: In case it has an OCM Address, it should first extract <spanx style="verb">&lt;fqdn&gt;</spanx> from it (the part after the <spanx style="verb">@</spanx> sign).
Step 2: The Discovering Server SHOULD attempt OCM API discovery a HTTP GET request to <spanx style="verb">https://&lt;fqdn&gt;/.well-known/ocm</spanx>.
Step 3: If that results in a valid HTTP response with a valid JSON response body within reasonable time, go to step 8.
Step 4: If not, try a HTTP GET with <spanx style="verb">https://&lt;fqdn&gt;/ocm-provider</spanx> as the URL instead.
Step 5: If that results in a valid HTTP response with a valid JSON response body within reasonable time, go to step 8.
Step 6: If not, and the <spanx style="verb">&lt;fqdn&gt;</spanx> came from an OCM Address, then it SHOULD check if the OCM Address in question was a Vanity OCM Address.
This can be checked with a <spanx style="verb">type=SRV</spanx> DNS query to <spanx style="verb">_ocm._tcp.&lt;fqdn&gt;</spanx>. If that returns <spanx style="verb">service = 10 10 443 &lt;regular-fqdn&gt;</spanx> then repeat from step 2, using <spanx style="verb">&lt;regular-fqdn&gt;</spanx> instead of the <spanx style="verb">&lt;fqdn&gt;</spanx> that appeared in the Vanity OCM Address.
Step 7: If not, fail.
Step 8: The JSON response body is the data that was discovered.</t>

</section>
<section anchor="fields"><name>Fields</name>
<t>The JSON response body offered by the Discoverable Server SHOULD contain the following information about its OCM API:</t>

<t><list style="symbols">
  <t>REQUIRED: enabled (boolean) - Whether the OCM service is enabled at this endpoint</t>
  <t>REQUIRED: apiVersion (string) - The OCM API version this endpoint supports. Example: <spanx style="verb">"1.1.0"</spanx></t>
  <t>REQUIRED: endPoint (string) - The URI of the OCM API available at this endpoint. Example: <spanx style="verb">"https://my-cloud-storage.org/ocm"</spanx></t>
  <t>OPTIONAL: provider (string) - A friendly branding name of this endpoint. Example: <spanx style="verb">"MyCloudStorage"</spanx></t>
  <t>REQUIRED: resourceTypes (array) - A list of all supported resource types with their access protocols. Each item in this list should
itself be an object containing the following fields:
  <list style="symbols">
      <t>name (string) -  A supported resource type (file, folder, calendar, contact, ...).
            Implementations MUST support <spanx style="verb">file</spanx> at a minimum. Each resource type is identified by its <spanx style="verb">name</spanx>: the list MUST NOT
      contain more than one resource type object per given <spanx style="verb">name</spanx>.</t>
      <t>shareTypes (array of string) -
            The supported recipient share types.
            MUST contain <spanx style="verb">"user"</spanx> at a minimum, plus optionally <spanx style="verb">"group"</spanx> and <spanx style="verb">"federation"</spanx>.
            Example: <spanx style="verb">["user"]</spanx></t>
      <t>protocols (object) - The supported protocols for accessing shared resources.
            Implementations MUST support at least <spanx style="verb">webdav</spanx> for <spanx style="verb">file</spanx> resources,
            any other combination of resources and protocols is optional. Example:
            <spanx style="verb">json
            {
              "webdav": "/remote/dav/ocm/",
              "webapp": "/app/ocm/",
              "talk": "/apps/spreed/api/"
            }
           </spanx>
            Fields:
      <list style="symbols">
          <t>webdav (string) - The top-level WebDAV path at this endpoint. In order to access
              a remote shared resource, implementations MAY use this path
              as a prefix, or as the full path (see sharing examples).</t>
          <t>webapp (string) - The top-level path for web apps at this endpoint. This value
              is provided for documentation purposes, and it SHALL NOT
              be intended as a prefix for share requests.</t>
          <t>datatx (string) - The top-level path to be used for data transfers. This
              value is provided for documentation purposes, and it SHALL
              NOT be intended as a prefix. In addition, implementations
              are expected to execute the transfer using WebDAV as
              the wire protocol.</t>
          <t>Any additional protocol supported for this resource type MAY
              be advertised here, where the value MAY correspond to a top-level
              URI to be used for that protocol.</t>
        </list></t>
    </list></t>
  <t>OPTIONAL: capabilities (array of string) - The optional capabilities supported by this OCM Server.
        As implementations MUST accept Share Creation Notifications to be compliant,
        it is not necessary to expose that as a capability.
        Example: <spanx style="verb">["/notifications"]</spanx>. The array MAY include for instance:
  <list style="symbols">
      <t><spanx style="verb">"/notifications"</spanx> - to indicate this OCM server is capable of processing OCM Notifications</t>
      <t><spanx style="verb">"/invite-accepted"</spanx> - to indicate that this OCM server is capable of processing Invite Acceptance Requests.</t>
      <t><spanx style="verb">"/mfa-capable"</spanx> - to indicate that this OCM server can apply a Sending Server's MFA requirements for a Share on their behalf.</t>
    </list></t>
  <t>OPTIONAL: publicKey (object) - The signatory used to sign outgoing request to confirm its origin. The 
        signatory is optional, but if present, it MUST contain two string fields, <spanx style="verb">id</spanx> and <spanx style="verb">publicKeyPem</spanx>.
      properties:
  <list style="symbols">
      <t>REQUIRED id (string) unique id of the key in URI format. The hostname set the origin of the 
          request and MUST be identical to the current discovery endpoint.
        Example: https://my-cloud-storage.org/ocm#signature</t>
      <t>REQUIRED publicKeyPem (string) - PEM-encoded version of the public key.
        Example: "-----BEGIN PUBLIC KEY-----\nMII...QDD\n-----END PUBLIC KEY-----\n"</t>
    </list></t>
</list></t>

</section>
</section>
<section anchor="share-creation-notification"><name>Share Creation Notification</name>
<t>To create a share, the sending server SHOULD make a HTTP POST request</t>

<t><list style="symbols">
  <t>to the <spanx style="verb">/shares</spanx> path in the Receiving Server's OCM API</t>
  <t>using <spanx style="verb">application/json</spanx> as the <spanx style="verb">Content-Type</spanx> HTTP request header</t>
  <t>its request body containing a JSON document representing an object with the fields as described below</t>
  <t>using TLS</t>
  <t>using <eref target="https://datatracker.ietf.org/doc/html/draft-cavage-http-signatures-12">httpsig</eref></t>
</list></t>

<section anchor="fields-1"><name>Fields</name>

<t><list style="symbols">
  <t>REQUIRED shareWith (string)
        Consumer specific identifier of the user, group or federation the provider
        wants to share the resource with. This is known in advance.
        Please note that the consumer service endpoint is known in advance
        as well, so this is no part of the request body.
      Example: "51dc30ddc473d43a6011e9ebba6ca770@geant.org"</t>
  <t>REQUIRED name (string)
     Name of the resource (file or folder).
      Example: "resource.txt"</t>
  <t>OPTIONAL description (string)
      Optional description of the resource (file or folder).
      Example: "This is the Open API Specification file (in YAML format) of the Open
        Cloud Mesh API."</t>
  <t>REQUIRED providerId (string)
        Identifier to identify the shared resource at the provider side. This is
        unique per provider such that if the same resource is shared twice,
        this providerId will not be repeated.
      Example: 7c084226-d9a1-11e6-bf26-cec0c932ce01</t>
  <t>REQUIRED owner (string) -
        Provider specific identifier of the user who owns the resource.
      Example: "6358b71804dfa8ab069cf05ed1b0ed2a@apiwise.nl"</t>
  <t>REQUIRED sender (string) -
        Provider specific identifier of the user that wants to share the
        resource. Please note that the requesting provider is being
        identified on a higher level, so the former <spanx style="verb">remote</spanx> property
        is not part of the request body.
      Example: "527bd5b5d689e2c32ae974c6229ff785@apiwise.nl"</t>
  <t>OPTIONAL ownerDisplayName (string)
        Display name of the owner of the resource
      Example: "Dimitri"</t>
  <t>OPTIONAL senderDisplayName (string)
        Display name of the user that wants to share the resource
      Example: "John Doe"</t>
  <t>REQUIRED shareType (string)
      SHOULD have a value of "user", "group", or "federation", to indicated that the first part
      of the <spanx style="verb">shareWith</spanx> OCM Address refers to a Receiving Party who is a single user of the Receiving Server,
      a group of users at the Receiving Servers, or a group of users that is spread out over various servers,
      including at least one user at the Receiving Server.</t>
  <t>REQUIRED resourceType (string)
        Resource type (file, folder, calendar, contact, ...)</t>
  <t>OPTIONAL expiration (integer)
        The expiration time for the OCM share, in seconds
        of UTC time since Unix epoch. If omitted, it is assumed
        that the share does not expire.</t>
  <t>OPTIONAL code (string)
        A nonce to be exchanged for a (potentially short-lived) bearer token at the Sending Server's /token endpoint.</t>
  <t>REQUIRED protocol (object)
        JSON object with specific options for each protocol.
        The supported protocols are:
        - <spanx style="verb">webdav</spanx>, to access the data
        - <spanx style="verb">webapp</spanx>, to access remote web applications
        - <spanx style="verb">datatx</spanx>, to transfer the data to the remote endpoint  <vspace blankLines='1'/>
    <figure><artwork><![CDATA[
    Other custom protocols might be added in the future.

    In case a single protocol is offered, there are three ways to specify this object:
    Option 1: Set the `name` field to the name of the protocol, and put the protocol
    details in a field named `options`.
    Option 2: Set the `name` field to the name of the protocol, and put the protocol
    details in a field carrying the name of the protocol.
    Option 3: Set the `name` field to `multi`, and put the protocol
    details in a field carrying the name of the protocol.

          Option 1 using the `options` field now deprecated. Implementations are encouraged to
          transition to the new optional properties defined below, such that
          this field may be removed in a future major version of the spec.

    When specifying more than one protocol as different ways to access the Share, the `name`
    field needs to be set to `multi`.
]]></artwork></figure>
  </t>
</list></t>

<t>If <spanx style="verb">multi</spanx> is given, one or more protocol
                endpoints are expected to be defined according to the optional
                properties specified below.
                Otherwise, at least <spanx style="verb">webdav</spanx> is expected to be supported, and
                its options MAY be given in the opaque <spanx style="verb">options</spanx> payload for
                compatibility with v1.0 implementations (see examples). Note
                though that this format is deprecated.
                Warning: client implementers should be aware that v1.1 servers
                MAY support both <spanx style="verb">webdav</spanx> and <spanx style="verb">multi</spanx>, but v1.0 servers MAY
                only support <spanx style="verb">webdav</spanx>.</t>

<t><list style="symbols">
  <t>Protocol details for <spanx style="verb">webdav</spanx> MAY contain:
  <list style="symbols">
      <t>OPTIONAL sharedSecret (string) - required if no <spanx style="verb">code</spanx> field is given for the Share as a whole (see above).
             An optional secret to be used to access the resource,
             such as a bearer token.
             To prevent leaking it in logs it MUST NOT appear in any URI.</t>
      <t>OPTIONAL permissions (array of strings) -
               The permissions granted to the sharee. A subset of:
               - <spanx style="verb">read</spanx> allows read-only access including download of a copy.
               - <spanx style="verb">write</spanx> allows create, update, and delete rights on the resource.
               - <spanx style="verb">share</spanx> allows re-share rights on the resource.
               - <spanx style="verb">mfa-enforced</spanx> requires the user accessing the resource to be
                 MFA-authenticated. This permission MAY be used if the
                 provider exposes the <spanx style="verb">mfa-capable</spanx> capability.</t>
      <t>OPTIONAL uri (string)
             An URI to access the remote resource. The URI MAY be relative,
             in which case the prefix exposed by the <spanx style="verb">/ocm-provider</spanx> endpoint MUST
             be used, or it may be absolute (recommended). Additionally, the URI
             MAY include a secret hash in the path, in which case there MAY be
             no associated <spanx style="verb">sharedSecret</spanx>.</t>
    </list></t>
  <t>Protocol details for <spanx style="verb">webapp</spanx> MAY contain:
  <list style="symbols">
      <t>REQUIRED uriTemplate (string)
             A templated URI to a client-browsable view of the shared resource,
             such that users may use the web applications available at the site.
             The URI MAY include a secret hash in the path. If the path includes
             a <spanx style="verb">{relative-path-to-shared-resource}</spanx> placeholder, implementations
             MAY replace it with the actual path to ease user interaction.</t>
      <t>REQUIRED viewMode (string)
             The permissions granted to the sharee. A subset of:
             - <spanx style="verb">view</spanx> allows access to the web app in view-only mode.
             - <spanx style="verb">read</spanx> allows read and download access via the web app.
             - <spanx style="verb">write</spanx> allows full editing rights via the web app.
             - <spanx style="verb">mfa-enforced</spanx> requires the user accessing the resource to be
               MFA-authenticated. This permission MAY be used if the
               provider exposes the <spanx style="verb">mfa-capable</spanx> capability.</t>
      <t>OPTIONAL sharedSecret (string)
             An optional secret to be used to access the remote web app,
             for example in the form of a bearer token.</t>
    </list></t>
  <t>Protocol details for <spanx style="verb">datatx</spanx> MAY contain:
  <list style="symbols">
      <t>OPTIONAL sharedSecret (string)
             An optional secret to be used to access the resource,
             for example in the form of a bearer token.
             To prevent leaking it in logs it MUST NOT appear in any URI.</t>
      <t>REQUIRED srcUri (string)
             An URI to access the remote resource. The URI MAY be relative,
             in which case the prefix exposed by the <spanx style="verb">/ocm-provider</spanx> endpoint MUST
             be used, or it may be absolute (recommended). Additionally, the
             URI MAY include a secret hash in the path.</t>
      <t>OPTIONAL size (integer)</t>
    </list></t>
</list></t>

</section>
<section anchor="decision-to-discard"><name>Decision to Discard</name>
<t>The Receiving Server MAY discard the notification if any of the following hold true:</t>

<t><list style="symbols">
  <t>the HTTP Signature is missing</t>
  <t>the HTTP Signature is not valid</t>
  <t>no keypair is trusted or discoverable from the FQDN part of the <spanx style="verb">sender</spanx> field in the request body</t>
  <t>the keypair used to generate the HTTP Signature doesn't match the one trusted or discoverable from the FQDN part of the <spanx style="verb">sender</spanx> field in the request body</t>
  <t>the Sending Server is denylisted</t>
  <t>the Sending Server is not allowlisted</t>
  <t>the Sending Party is not trusted by the Receiving Party (e.g. no Invite was exchanged and/or the Sending Party's OCM Address does not appear in the Receiving Party's address book)</t>
  <t>the Receiving Server is unable to act as an API client for (any of) the protocol(s) listed for accessing the resource</t>
  <t>an initial check shows that the resource cannot successfully accessed through (any of) the protocol(s) listed</t>
</list></t>

</section>
</section>
<section anchor="receiving-party-notification"><name>Receiving Party Notification</name>
<t>If the Share Creation Notification is not discarded by the Receiving Server, they MAY notify the Receiving Party passively by adding the Share to some inbox list, and MAY also notify them actively through for instance a push notification or an email message.</t>

<t>They could give the Receiving Party the option to accept or reject the share, or add the share automatically and only send an informational notification that this happened.</t>

</section>
<section anchor="share-acceptance-notification"><name>Share Acceptance Notification</name>
<t>In response to a Share Creation Notification, the Receiving Server MAY discover the OCM API of the Sending Server,
starting from the <spanx style="verb">&lt;fqdn&gt;</spanx> part of the <spanx style="verb">sender</spanx> field in the Share Creation Notification.
Note that the <spanx style="verb">sender</spanx> field is not allowed to contain a Vanity OCM Address, so the fallback to SRV DNS records is not necessary in this OCM API discovery process.</t>

<t>If the OCM API of the Sending Server is successfully discovered, the Receiving Server MAY
make a HTTP POST request</t>

<t><list style="symbols">
  <t>to the <spanx style="verb">/notifications</spanx> path in the Sending Server's OCM API</t>
  <t>using <spanx style="verb">application/json</spanx> as the <spanx style="verb">Content-Type</spanx> HTTP request header</t>
  <t>its request body containing a JSON document representing an object with the fields as described below</t>
  <t>using TLS</t>
  <t>using <eref target="https://datatracker.ietf.org/doc/html/draft-cavage-http-signatures-12">httpsig</eref></t>
</list></t>

<section anchor="fields-2"><name>Fields</name>

<t><list style="symbols">
  <t>REQUIRED notificationType (string) - in a Share Acceptance Notification it SHOULD be one of:
  <list style="symbols">
      <t>'SHARE_ACCEPTED'</t>
      <t>'SHARE_DECLINED'</t>
    </list></t>
  <t>REQUIRED providerId (string) - copied from the Share Creation Notification for the Share this notification is about</t>
  <t>OPTIONAL resourceType (string) - copied from the Share Creation Notification for the Share this notification is about</t>
  <t>OPTIONAL notification (object) - optional additional parameters, depending on the notification and the resource type</t>
</list></t>

</section>
</section>
<section anchor="resource-access"><name>Resource Access</name>
<t>To access the Resource, the Receiving Server MAY use multiple ways, depending on the body of the Share Creation Notification and on the <spanx style="verb">protocol.name</spanx> property in there:</t>

<t><list style="symbols">
  <t>If <spanx style="verb">protocol.name</spanx> = <spanx style="verb">multi</spanx>, the receiver MUST make a HTTP PROPFIND request to <spanx style="verb">protocol.webdav.uri</spanx> to access the remote share.
If <spanx style="verb">code</spanx> is not empty, the receiver SHOULD discover the sender's OCM endpoint and make a signed POST request to the <spanx style="verb">/token</spanx> path inside the Sending Server's OCM API, to exchange
the code for a short-lived bearer token,
and then use that bearer token to access the Resource.
Otherwise, if <spanx style="verb">protocol.webdav.sharedSecret</spanx> is not empty, the receiver MUST pass it as a <spanx style="verb">Authorization: bearer</spanx> header.</t>
  <t>If <spanx style="verb">protocol.name</spanx> = <spanx style="verb">webdav</spanx>, the receiver SHOULD inspect the <spanx style="verb">protocol.options</spanx> property. If it contains a <spanx style="verb">sharedSecret</spanx>, as in the <eref target="https://cs3org.github.io/OCM-API/docs.html?branch=develop&amp;repo=OCM-API&amp;user=cs3org#/paths/~1shares/post">legacy example</eref>, then the receiver SHOULD make a HTTP PROPFIND request to <spanx style="verb">https://&lt;sharedSecret&gt;:@&lt;host&gt;&lt;path&gt;</spanx>, where <spanx style="verb">&lt;host&gt;</spanx> is the remote server, and <spanx style="verb">&lt;path&gt;</spanx> is obtained by querying the <xref target="ocm-api-discovery">Discovery</xref> endpoint at the Sending Server and getting <spanx style="verb">resourceTypes[0].protocols.webdav</spanx>. Note that this access method is <em>deprecated</em> and may be removed in a future release of the Protocol.</t>
</list></t>

<t>In both cases, when the Resource is a folder and the Receiving Server accesses a resource within that shared folder, it SHOULD append its relative path to that URL.</t>

<t>Additionally, if <spanx style="verb">protocol.&lt;protocolname&gt;.permissions</spanx> include <spanx style="verb">mfa-enforced</spanx>, the Receiving Server MUST ensure that the Receiving Party has been authenticated with MFA.</t>

</section>
<section anchor="share-deletion"><name>Share Deletion</name>
<t>A <spanx style="verb">"SHARE_ACCEPTED"</spanx> notification followed by a <spanx style="verb">"SHARE_UNSHARED"</spanx> notification is
equivalent to a <spanx style="verb">"SHARE_DECLINED"</spanx> notification.</t>

<t>Note that the Sending Server MAY at any time revoke access to a Resource (effectively undoing or deleting the Share) without notifying the Receiving Server.</t>

</section>
<section anchor="share-updating"><name>Share Updating</name>
<t>TODO: document <spanx style="verb">"RESHARE_CHANGE_PERMISSION"</spanx></t>

</section>
<section anchor="resharing"><name>Resharing</name>
<t>The <spanx style="verb">"REQUEST_RESHARE"</spanx> and <spanx style="verb">"RESHARE_UNDO"</spanx> notification types MAY be used by the
Receiving Server to persuade the Sending Server to share the same Resource with another Receiving Party.
TODO: document how the Receiving Party can know if the Sending Party understood and processed the
reshare request.</t>

</section>
<section anchor="appendix-a-multi-factor-authentication"><name>Appendix A: Multi Factor Authentication</name>
<t>If a Receiving Server exposes the capability <spanx style="verb">/mfa-capable</spanx>, it indicates that it will try and comply with a MFA requirement set as a permission on a Share. If the Sending Server trusts the Receiving Server, the Sending Server MAY set the permission <spanx style="verb">mfa-enforced</spanx> on a Share, which the Receiving Server SHOULD honor. A compliant Receiving Server that signals that it is MFA-capable MUST not allow access to a resource protected with the <spanx style="verb">mfa-enforced</spanx> permission, if the Receiving Party has not provided a second factor to establish their identity with greater confidence.</t>

<t>Since there is no way to guarantee that the Receiving Server will actually enforce the MFA requirement, it is up to the Sending Server to establish a trust with the Receiving Server such that it is reasonable to assume that the Receiving Server will honor the MFA requirement. This establishment of trust will inevitably be implementation dependent, and can be done for example using a pre approved allow list of trusted Receiving Servers. The procedure of establishing trust is out of scope for this specification: a mechanism similar to the <eref target="https://sciencemesh.io">ScienceMesh</eref> integration for the <xref target="invite-flow">Invite</xref> capability may be envisaged.</t>

<section anchor="appendix-b-request-signing"><name>Appendix B: Request Signing</name>

<t>A request is signed by adding the signature in the headers. The sender also needs to expose the public key used to generate the signature. The receiver can then validate the signature and therefore the origin of the request.
To help debugging, it is recommended to also add all properties used in the signature as headers, even if they can easily be re-generated from the payload.</t>

<t>Note: Signed requests prove the identity of the sender but does not encrypt nor affect its payload.</t>

<t>Here is an example of headers needed to sign a request.</t>

<figure><artwork><![CDATA[
  {
    "(request-target)": "post /path",
    "content-length": 380,
    "date": "Mon, 08 Jul 2024 14:16:20 GMT",
    "digest": "SHA-256=U7gNVUQiixe5BRbp4Tg0xCZMTcSWXXUZI2\\/xtHM40S0=",
    "host": "hostname.of.the.recipient",
    "Signature": "keyId=\"https://author.hostname/key\",algorithm=\"rsa-sha256\",headers=\"content-length date digest host\",signature=\"DzN12OCS1rsA[...]o0VmxjQooRo6HHabg==\""
  }
]]></artwork></figure>

<t><list style="symbols">
  <t>'(request-target)' contains the reached endpoint and the used method,</t>
  <t>'content-length' is the total length of the payload of the request,</t>
  <t>'date' is the date and time when the request has been sent,</t>
  <t>'digest' is a checksum of the payload of the request,</t>
  <t>'host' is the hostname of the recipient of the request (remote when signing outgoing request, local on incoming request),</t>
  <t>'Signature' contains the signature generated using the private key and details on its generation:
  <list style="symbols">
      <t>'keyId' is a unique id, formatted as an url. hostname is used to retrieve the public key via custom discovery</t>
      <t>'algorithm' specify the algorithm used to generate signature</t>
      <t>'headers' specify the properties used when generating the signature</t>
      <t>'signature' the signature of an array containing the properties listed in 'headers'. Some properties like content-length, date, digest, and host are mandatory to protect against authenticity override.</t>
    </list></t>
</list></t>

<section anchor="how-to-generate-the-signature-for-outgoing-request"><name>How to generate the Signature for outgoing request</name>

<t>After properties are set in the headers, the Signature is generated and added to the list.</t>

<t>This is a quick PHP example of headers for outgoing request:</t>

<figure><artwork><![CDATA[
    $headers = [
        '(request-target)' => 'post /path',
        'content-length' => strlen($payload),
        'date' => gmdate('D, d M Y H:i:s T'),
        'digest': 'SHA-256=' . base64_encode(hash('sha256', utf8_encode($payload), true)),
        'host': 'hostname.of.the.recipient',
    ];

    openssl_sign(implode("\n", $headers), $signed, $privateKey, OPENSSL_ALGO_SHA256);

    $signature = [
        'keyId' => 'https://author.hostname/key',
        'algorithm' => 'rsa-sha256',
        'headers' => 'content-length date digest host',
        'signature' => $signed
    ];

    $headers['Signature'] = implode(',', $signature);
]]></artwork></figure>

</section>
<section anchor="how-to-confirm-signature-on-incoming-request"><name>How to confirm Signature on incoming request</name>

<t>The first step would be to confirm the validity of each properties:</t>

<t><list style="symbols">
  <t>'(request-target)' and 'host' are immutable to the type of the request and the local/current host,</t>
  <t>'content-length' and 'digest' can be re-generated and compared from the payload of the request,</t>
  <t>A maximum TTL must be applied to 'date' and current timestamp,</t>
  <t>regarding data contained in the 'Signature' header:
  <list style="symbols">
      <t>using 'keyId' to get the public key from remote signatory,</t>
      <t>'headers' is used to generate the clear version of the signature and must contain at least 'content-length', 'date', 'digest' and 'host',</t>
      <t>'signature' is the encrypted version of the signature.</t>
    </list></t>
</list></t>

<t>Here is an example of how to verify the signature using the headers, the signature and the public key:</t>

<figure><artwork><![CDATA[
    $clear = [
        '(request-target)' => 'post /path',
        'content-length' => strlen($payload),
        'date' => 'Mon, 08 Jul 2024 14:16:20 GMT',
        'digest': 'SHA-256=' . base64_encode(hash('sha256', utf8_encode($payload), true)),
        'host': $localhost
    ];

    $signed = "DzN12OCS1rsA[...]o0VmxjQooRo6HHabg==";
    if (openssl_verify(implode("\n", $clear), $signed, $publicKey, 'sha256') !== 1) {
        throw new InvalidSignatureException('signature issue');
    }
]]></artwork></figure>

</section>
<section anchor="validating-the-payload"><name>Validating the payload</name>

<t>Following the validation of the signature, the host should also confirm the validity of the payload, that is ensuring that the actions implied in the payload actually initiated on behalf of the source of the request.</t>

<t>As an example, if the payload is about initiating a new share the file owner has to be an account from the instance at the origin of the request.</t>

</section>
</section>
</section>


  </middle>

  <back>








  </back>

<!-- ##markdown-source:
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
XnrW+29PJ9TZFqgAAA==

-->

</rfc>

